<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">



  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.cat.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="博客：blog.shinelee.me | 博客园 | CSDN 写在前面在Caffe源码理解1中介绍了Blob类，其中的数据成员有 12shared_ptr&amp;lt;SyncedMemory&amp;gt; data_;shared_ptr&amp;lt;SyncedMemory&amp;gt; diff_; std::shared_ptr 是共享对象所有权的智能指针，当最后一个占有对象的shared_ptr被销毁或再赋">
<meta name="keywords" content="caffe">
<meta property="og:type" content="article">
<meta property="og:title" content="Caffe源码理解2：SyncedMemory CPU和GPU间的数据同步">
<meta property="og:url" content="https://blog.shinelee.me/2018/12-01-Caffe源码理解2：SyncedMemory-CPU和GPU间的数据同步.html">
<meta property="og:site_name" content="本立2道生">
<meta property="og:description" content="博客：blog.shinelee.me | 博客园 | CSDN 写在前面在Caffe源码理解1中介绍了Blob类，其中的数据成员有 12shared_ptr&amp;lt;SyncedMemory&amp;gt; data_;shared_ptr&amp;lt;SyncedMemory&amp;gt; diff_; std::shared_ptr 是共享对象所有权的智能指针，当最后一个占有对象的shared_ptr被销毁或再赋">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s1.ax1x.com/2018/12/01/FnY2OU.png">
<meta property="og:updated_time" content="2019-01-07T06:50:48.519Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Caffe源码理解2：SyncedMemory CPU和GPU间的数据同步">
<meta name="twitter:description" content="博客：blog.shinelee.me | 博客园 | CSDN 写在前面在Caffe源码理解1中介绍了Blob类，其中的数据成员有 12shared_ptr&amp;lt;SyncedMemory&amp;gt; data_;shared_ptr&amp;lt;SyncedMemory&amp;gt; diff_; std::shared_ptr 是共享对象所有权的智能指针，当最后一个占有对象的shared_ptr被销毁或再赋">
<meta name="twitter:image" content="https://s1.ax1x.com/2018/12/01/FnY2OU.png">






  <link rel="canonical" href="https://blog.shinelee.me/2018/12-01-Caffe源码理解2：SyncedMemory-CPU和GPU间的数据同步.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Caffe源码理解2：SyncedMemory CPU和GPU间的数据同步 | 本立2道生</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">本立2道生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.shinelee.me/2018/12-01-Caffe源码理解2：SyncedMemory-CPU和GPU间的数据同步.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李拜六不开鑫">
      <meta itemprop="description" content="胸怀万里，不如脚下一步">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="本立2道生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Caffe源码理解2：SyncedMemory CPU和GPU间的数据同步
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-01 16:50:49" itemprop="dateCreated datePublished" datetime="2018-12-01T16:50:49+08:00">2018-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-07 14:50:48" itemprop="dateModified" datetime="2019-01-07T14:50:48+08:00">2019-01-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/库与框架/" itemprop="url" rel="index"><span itemprop="name">库与框架</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/12-01-Caffe源码理解2：SyncedMemory-CPU和GPU间的数据同步.html" class="leancloud_visitors" data-flag-title="Caffe源码理解2：SyncedMemory CPU和GPU间的数据同步">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">7k</span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>博客：<a href="https://blog.shinelee.me/">blog.shinelee.me</a> | <a href="https://www.cnblogs.com/shine-lee/" target="_blank" rel="noopener">博客园</a> | <a href="https://blog.csdn.net/blogshinelee" target="_blank" rel="noopener">CSDN</a></p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在Caffe源码理解1中介绍了<code>Blob</code>类，其中的数据成员有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;SyncedMemory&gt; data_;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;SyncedMemory&gt; diff_;</span><br></pre></td></tr></table></figure>
<p><code>std::shared_ptr</code> 是共享对象所有权的智能指针，当最后一个占有对象的<code>shared_ptr</code>被销毁或再赋值时，对象会被自动销毁并释放内存，见<a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener">cppreference.com</a>。而<code>shared_ptr</code>所指向的<code>SyncedMemory</code>即是本文要讲述的重点。</p>
<p>在Caffe中，<code>SyncedMemory</code>有如下两个特点：</p>
<ul>
<li><strong>屏蔽了CPU和GPU上的内存管理以及数据同步细节</strong></li>
<li><strong>通过惰性内存分配与同步，提高效率以及节省内存</strong></li>
</ul>
<p>背后是怎么实现的？希望通过这篇文章可以将以上两点讲清楚。</p>
<h1 id="成员变量的含义及作用"><a href="#成员变量的含义及作用" class="headerlink" title="成员变量的含义及作用"></a>成员变量的含义及作用</h1><p><code>SyncedMemory</code>的数据成员如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SyncedHead &#123; UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU, SYNCED &#125;;</span><br><span class="line"><span class="keyword">void</span>* cpu_ptr_; <span class="comment">// CPU侧数据指针</span></span><br><span class="line"><span class="keyword">void</span>* gpu_ptr_; <span class="comment">// GPU侧数据指针</span></span><br><span class="line"><span class="keyword">size_t</span> size_; <span class="comment">// 数据所占用的内存大小</span></span><br><span class="line">SyncedHead head_; <span class="comment">// 指示再近一次数据更新发生在哪一侧，在调用另一侧数据时需要将该侧数据同步过去</span></span><br><span class="line"><span class="keyword">bool</span> own_cpu_data_; <span class="comment">// 指示cpu_ptr_是否为对象内部调用CaffeMallocHost分配的CPU内存</span></span><br><span class="line"><span class="keyword">bool</span> cpu_malloc_use_cuda_; <span class="comment">// 指示是否使用cudaMallocHost分配页锁定内存，系统malloc分配的是可分页内存，前者更快</span></span><br><span class="line"><span class="keyword">bool</span> own_gpu_data_; <span class="comment">// 指示gpu_ptr_是否为对象内部调用cudaMalloc分配的GPU内存</span></span><br><span class="line"><span class="keyword">int</span> device_; <span class="comment">// GPU设备号</span></span><br></pre></td></tr></table></figure></p>
<p><code>cpu_ptr_</code>和<code>gpu_ptr_</code>所指向的数据空间有两种来源，一种是<strong>对象内部自己分配的</strong>，一种是<strong>外部指定的</strong>，为了区分这两种情况，于是有了<code>own_cpu_data_</code>和<code>own_gpu_data_</code>，当为<code>true</code>时表示是对象内部自己分配的，因此需要对象自己负责释放（析构函数），如果是外部指定的，则由外部负责释放，即<strong>谁分配谁负责释放</strong>。</p>
<p>外部指定数据时需调用<code>set_cpu_data</code>和<code>set_gpu_data</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SyncedMemory::set_cpu_data(<span class="keyword">void</span>* data) &#123;</span><br><span class="line">  check_device(); </span><br><span class="line">  CHECK(data);</span><br><span class="line">  <span class="keyword">if</span> (own_cpu_data_) &#123; <span class="comment">// 如果自己分配过内存，先释放，换外部指定数据</span></span><br><span class="line">    CaffeFreeHost(cpu_ptr_, cpu_malloc_use_cuda_);</span><br><span class="line">  &#125;</span><br><span class="line">  cpu_ptr_ = data; <span class="comment">// 直接指向外部数据</span></span><br><span class="line">  head_ = HEAD_AT_CPU; <span class="comment">// 指示CPU侧更新了数据</span></span><br><span class="line">  own_cpu_data_ = <span class="literal">false</span>; <span class="comment">// 指示数据来源于外部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SyncedMemory::set_gpu_data(<span class="keyword">void</span>* data) &#123;</span><br><span class="line">  check_device();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">  CHECK(data);</span><br><span class="line">  <span class="keyword">if</span> (own_gpu_data_) &#123; <span class="comment">// 如果自己分配过内存，先释放，换外部指定数据</span></span><br><span class="line">    CUDA_CHECK(cudaFree(gpu_ptr_));</span><br><span class="line">  &#125;</span><br><span class="line">  gpu_ptr_ = data; <span class="comment">// 直接指向外部数据</span></span><br><span class="line">  head_ = HEAD_AT_GPU; <span class="comment">// 指示GPU侧更新了数据</span></span><br><span class="line">  own_gpu_data_ = <span class="literal">false</span>; <span class="comment">// 指示数据来源于外部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  NO_GPU;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h1><p>在<code>SyncedMemory</code>构造函数中，获取GPU设备（如果使用了GPU的话），注意构造时<code>head_ = UNINITIALIZED</code>，<strong>初始化成员变量，但并没有真正的分配内存</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造</span></span><br><span class="line">SyncedMemory::SyncedMemory(<span class="keyword">size_t</span> size)</span><br><span class="line">  : cpu_ptr_(<span class="literal">NULL</span>), gpu_ptr_(<span class="literal">NULL</span>), size_(size), head_(UNINITIALIZED),</span><br><span class="line">    own_cpu_data_(<span class="literal">false</span>), cpu_malloc_use_cuda_(<span class="literal">false</span>), own_gpu_data_(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  CUDA_CHECK(cudaGetDevice(&amp;device_));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构</span></span><br><span class="line">SyncedMemory::~SyncedMemory() &#123;</span><br><span class="line">  check_device(); <span class="comment">// 校验当前GPU设备以及gpu_ptr_所指向的设备是不是构造时获取的GPU设备</span></span><br><span class="line">  <span class="keyword">if</span> (cpu_ptr_ &amp;&amp; own_cpu_data_) &#123; <span class="comment">// 自己分配的空间自己负责释放</span></span><br><span class="line">    CaffeFreeHost(cpu_ptr_, cpu_malloc_use_cuda_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">  <span class="keyword">if</span> (gpu_ptr_ &amp;&amp; own_gpu_data_) &#123; <span class="comment">// 自己分配的空间自己负责释放</span></span><br><span class="line">    CUDA_CHECK(cudaFree(gpu_ptr_));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CPU_ONLY</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放CPU内存</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CaffeFreeHost</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">bool</span> use_cuda)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">  <span class="keyword">if</span> (use_cuda) &#123;</span><br><span class="line">    CUDA_CHECK(cudaFreeHost(ptr));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MKL</span></span><br><span class="line">  mkl_free(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，在析构函数中，却释放了CPU和GPU的数据指针，那么是什么时候分配的内存呢？这就要提到，Caffe官网中说的“<strong>在需要时分配内存</strong>” ，以及“<strong>在需要时同步CPU和GPU</strong>”，这样做是为了<strong>提高效率</strong>、<strong>节省内存</strong>。</p>
<blockquote>
<p>Blobs conceal the computational and mental overhead of mixed CPU/GPU operation by synchronizing from the CPU host to the GPU device as needed. Memory on the host and device is allocated on demand (lazily) for efficient memory usage.</p>
</blockquote>
<p>具体怎么实现的？我们接着往下看。</p>
<h1 id="内存同步管理"><a href="#内存同步管理" class="headerlink" title="内存同步管理"></a>内存同步管理</h1><p><code>SyncedMemory</code>成员函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">cpu_data</span><span class="params">()</span></span>; <span class="comment">// to_cpu(); return (const void*)cpu_ptr_; 返回CPU const指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cpu_data</span><span class="params">(<span class="keyword">void</span>* data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">gpu_data</span><span class="params">()</span></span>; <span class="comment">// to_gpu(); return (const void*)gpu_ptr_; 返回GPU const指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gpu_data</span><span class="params">(<span class="keyword">void</span>* data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mutable_cpu_data</span><span class="params">()</span></span>; <span class="comment">// to_cpu(); head_ = HEAD_AT_CPU; return cpu_ptr_; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mutable_gpu_data</span><span class="params">()</span></span>; <span class="comment">// to_gpu(); head_ = HEAD_AT_GPU; return gpu_ptr_;</span></span><br><span class="line"><span class="keyword">enum</span> SyncedHead &#123; UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU, SYNCED &#125;;</span><br><span class="line"><span class="function">SyncedHead <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head_; &#125;</span><br><span class="line"><span class="keyword">size_t</span> size() &#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">async_gpu_push</span><span class="params">(<span class="keyword">const</span> cudaStream_t&amp; stream)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>cpu_data()</code>和<code>gpu_data()</code>返回<code>const</code>指针只读不写，<code>mutable_cpu_data()</code>和<code>mutable_gpu_data()</code>返回可写指针，它们4个在获取数据指针时均调用了<code>to_cpu()</code>或<code>to_gpu()</code>，两者内部逻辑一样，<strong>内存分配发生在第一次访问某一侧数据时分配该侧内存</strong>，如果不曾访问过则不分配内存，以此按需分配来节省内存。同时，用<code>head_</code>来指示<strong>最近一次数据更新发生在哪一侧，仅在调用另一侧数据时才将该侧数据同步过去，如果访问的仍是该侧，则不会发生同步，当两侧已同步都是最新时，即</strong><code>head_=SYNCED</code>，<strong>访问任何一侧都不会发生数据同步</strong>。下面以<code>to_cpu()</code>为例，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SyncedMemory::to_cpu() &#123;</span><br><span class="line">  check_device();</span><br><span class="line">  <span class="keyword">switch</span> (head_) &#123;</span><br><span class="line">  <span class="keyword">case</span> UNINITIALIZED: <span class="comment">// 如果未分配过内存（构造函数后就是这个状态）</span></span><br><span class="line">    CaffeMallocHost(&amp;cpu_ptr_, size_, &amp;cpu_malloc_use_cuda_); <span class="comment">// to_CPU时为CPU分配内存</span></span><br><span class="line">    caffe_memset(size_, <span class="number">0</span>, cpu_ptr_); <span class="comment">// 数据清零</span></span><br><span class="line">    head_ = HEAD_AT_CPU; <span class="comment">// 指示CPU更新了数据</span></span><br><span class="line">    own_cpu_data_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> HEAD_AT_GPU: <span class="comment">// 如果GPU侧更新过数据，则同步到CPU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">    <span class="keyword">if</span> (cpu_ptr_ == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果CPU侧没分配过内存，分配内存</span></span><br><span class="line">      CaffeMallocHost(&amp;cpu_ptr_, size_, &amp;cpu_malloc_use_cuda_);</span><br><span class="line">      own_cpu_data_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    caffe_gpu_memcpy(size_, gpu_ptr_, cpu_ptr_); <span class="comment">// 数据同步</span></span><br><span class="line">    head_ = SYNCED; <span class="comment">// 指示CPU和GPU数据已同步一致</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    NO_GPU;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> HEAD_AT_CPU: <span class="comment">// 如果CPU数据是最新的，不操作</span></span><br><span class="line">  <span class="keyword">case</span> SYNCED: <span class="comment">// 如果CPU和GPU数据都是最新的，不操作</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配CPU内存</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CaffeMallocHost</span><span class="params">(<span class="keyword">void</span>** ptr, <span class="keyword">size_t</span> size, <span class="keyword">bool</span>* use_cuda)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPU_ONLY</span></span><br><span class="line">  <span class="keyword">if</span> (Caffe::mode() == Caffe::GPU) &#123;</span><br><span class="line">    CUDA_CHECK(cudaMallocHost(ptr, size)); <span class="comment">// cuda malloc</span></span><br><span class="line">    *use_cuda = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MKL</span></span><br><span class="line">  *ptr = mkl_malloc(size ? size:<span class="number">1</span>, <span class="number">64</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  *use_cuda = <span class="literal">false</span>;</span><br><span class="line">  CHECK(*ptr) &lt;&lt; <span class="string">"host allocation of size "</span> &lt;&lt; size &lt;&lt; <span class="string">" failed"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一下<code>head_</code>状态是如何转换的，如下图所示：</p>
<p><figure><img src="https://s1.ax1x.com/2018/12/01/FnY2OU.png" alt="head_状态转换"><figcaption class="image-caption">head_状态转换</figcaption></figure></p>
<p>若以<code>X</code>指代CPU或GPU，<code>Y</code>指代GPU或CPU，<strong>需要注意的是</strong>，如果<code>HEAD_AT_X</code>表明<code>X</code>侧为最新数据，调用<code>mutable_Y_data()</code>时，在<code>to_Y()</code>内部会将<code>X</code>侧数据同步至<code>Y</code>，<strong>会暂时将状态置为</strong><code>SYNCED</code>，但退出<code>to_Y()</code>后<strong>最终仍会将状态置为</strong><code>HEAD_AT_Y</code>，如<code>mutable_cpu_data()</code>代码所示，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* SyncedMemory::mutable_cpu_data() &#123;</span><br><span class="line">  check_device();</span><br><span class="line">  to_cpu();</span><br><span class="line">  head_ = HEAD_AT_CPU;</span><br><span class="line">  <span class="keyword">return</span> cpu_ptr_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管之前是何种状态，只要调用了<code>mutable_Y_data()</code>，则<code>head_</code>就为<code>HEAD_AT_Y</code>。背后的思想是，无论当前是<code>HEAD_AT_X</code>还是<code>SYNCED</code>，<strong>只要调用了</strong><code>mutable_Y_data()</code>，<strong>就意味着调用者可能会修改</strong><code>Y</code><strong>侧数据</strong>，<strong>所以认为接下来</strong><code>Y</code><strong>侧数据是最新的</strong>，因此将其置为<code>HEAD_AT_Y</code>。</p>
<p>至此，就可以理解Caffe官网上提供的何时发生内存同步的例子，以及为什么建议不修改数据时要调用<code>const</code>函数，不要调用<code>mutable</code>函数了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming that data are on the CPU initially, and we have a blob.</span></span><br><span class="line"><span class="keyword">const</span> Dtype* foo;</span><br><span class="line">Dtype* bar;</span><br><span class="line">foo = blob.gpu_data(); <span class="comment">// data copied cpu-&gt;gpu.</span></span><br><span class="line">foo = blob.cpu_data(); <span class="comment">// no data copied since both have up-to-date contents.</span></span><br><span class="line">bar = blob.mutable_gpu_data(); <span class="comment">// no data copied.</span></span><br><span class="line"><span class="comment">// ... some operations ...</span></span><br><span class="line">bar = blob.mutable_gpu_data(); <span class="comment">// no data copied when we are still on GPU.</span></span><br><span class="line">foo = blob.cpu_data(); <span class="comment">// data copied gpu-&gt;cpu, since the gpu side has modified the data</span></span><br><span class="line">foo = blob.gpu_data(); <span class="comment">// no data copied since both have up-to-date contents</span></span><br><span class="line">bar = blob.mutable_cpu_data(); <span class="comment">// still no data copied.</span></span><br><span class="line">bar = blob.mutable_gpu_data(); <span class="comment">// data copied cpu-&gt;gpu.</span></span><br><span class="line">bar = blob.mutable_cpu_data(); <span class="comment">// data copied gpu-&gt;cpu.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A rule of thumb is, always use the const call if you do not want to change the values, and never store the pointers in your own object. Every time you work on a blob, call the functions to get the pointers, as the SyncedMem will need this to figure out when to copy data.</p>
</blockquote>
<p>以上。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://caffe.berkeleyvision.org/tutorial/net_layer_blob.html" target="_blank" rel="noopener">Blobs, Layers, and Nets: anatomy of a Caffe model</a></li>
<li><a href="https://blog.csdn.net/dcrmg/article/details/54975432" target="_blank" rel="noopener">cudaMallocHost函数详解</a></li>
</ul>

      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>李拜六不开鑫</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.shinelee.me/2018/12-01-Caffe源码理解2：SyncedMemory-CPU和GPU间的数据同步.html" title="Caffe源码理解2：SyncedMemory CPU和GPU间的数据同步">https://blog.shinelee.me/2018/12-01-Caffe源码理解2：SyncedMemory-CPU和GPU间的数据同步.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/caffe/" rel="tag"># caffe</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11-30-人脸识别相关开源项目汇总.html" rel="next" title="人脸识别相关开源项目汇总">
                <i class="fa fa-chevron-left"></i> 人脸识别相关开源项目汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12-04-人脸检测中，如何构建输入图像金字塔.html" rel="prev" title="人脸检测中，如何构建输入图像金字塔">
                人脸检测中，如何构建输入图像金字塔 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNzczMy8xNDI2NA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="李拜六不开鑫">
            
              <p class="site-author-name" itemprop="name">李拜六不开鑫</p>
              <p class="site-description motion-element" itemprop="description">胸怀万里，不如脚下一步</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/shineleex" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/blogshinelee" title="csdn" target="_blank">csdn</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/shine-lee/" title="cnblogs" target="_blank">cnblogs</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#成员变量的含义及作用"><span class="nav-number">2.</span> <span class="nav-text">成员变量的含义及作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造与析构"><span class="nav-number">3.</span> <span class="nav-text">构造与析构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存同步管理"><span class="nav-number">4.</span> <span class="nav-text">内存同步管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李拜六不开鑫</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">86k</span>
  

  
</div>








  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("yglgMSc5V7E9a3RgMhNNxIue-gzGzoHsz", "GCjFI0Chd35pvUysMqtIlctF");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var newcounter = new Counter();
              /* Set ACL */
              var acl = new AV.ACL();
              acl.setPublicReadAccess(true);
              acl.setPublicWriteAccess(true);
              newcounter.setACL(acl);
              /* End Set ACL */
              newcounter.set("title", title);
              newcounter.set("url", url);
              newcounter.set("time", 1);
              newcounter.save(null, {
                success: function(newcounter) {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                },
                error: function(newcounter, error) {
                  console.log('Failed to create');
                }
              });
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "middleCenter";
      
          pbOptions.networks = "Wechat,Weibo,Douban,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Wechat,Weibo,Douban,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.3.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.3.0"></script>


  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
